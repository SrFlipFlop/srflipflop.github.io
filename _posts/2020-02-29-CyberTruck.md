---
layout: post
title: "CyberTruck Challange"
date: 2020-02-29 
description: "Writeup of CyberTruck Challange"
tag: Reversing
---   

This time we are going to face a very funny challenge to refresh our reversing knowledge. It is an Android application that uses different encrypted keys to start a truck. Our goal is to get those keys generated by the application and also the seeds that we will find in the code.

### Bypass controls

The first thing we have to do is to examine what protection mechanisms exist in the application. Just with an overview of the `MainActivity`, we see that inside the `onCheckedChanged` method a suspicious class is used and the application is closed depending on the result.

![](/images/posts/CyberTruck19/img1.png "Main Activity")

If we take a closer look at the `HookDetector` class, we see how the `isFridaServerInDevice` method check if certain files are on the device. 

![](/images/posts/CyberTruck19/img2.png "Frida detector")

To bypass it we could simply modify the *Frida* server name so that it is not detected, or we can directly use *Frida* to hook the `HookDetector.isFridaServerInDevice` function and always return **false**.

![](/images/posts/CyberTruck19/img3.png "Frida script")

As we can see below, now when using the application we can see how the function we have hooked is executed and the result it returns is modified.

![](/images/posts/CyberTruck19/img4.png "Frida detector bypass ")

### Challange 1

In the first challenge, we find how the application generates the dynamic key to start the vehicle. To do this, it uses the Data Encryption Standard (DES) encryption algorthim with the key **s3cr3t$ n3veR mUst bE h4rdc0d$d m4t3!**, to encrypt the **CyB3r_tRucK_Ch4113ng3** seed.

![](/images/posts/CyberTruck19/img5.png "Challange 1 code")

In order to obtain the key, we are going to use the following *Frida* script that will allow us to modify the function `Challange1.generateDynamicKey` implemetation and print the dynamic key.

![](/images/posts/CyberTruck19/img6.png "Frida script")

We can see that our script shows us the different keys that we have mentioned during the static analysis and that the final result is a cryptographic key **046e...a8c6**.  

![](/images/posts/CyberTruck19/img7.png "Dynamic key")

### Challange 2

In the second CyberTruck challenge they have applied some obfuscation layer in the class names and methods. To make the explanation easier we will rename the functions:
- Function 1 -> a(Context) returns void
- Function 2 -> a(Context) returns byte array
- Function 3 -> a(byte array, byte array) returns byte array

We can see that inside *function1*, *function3* is called with the parameters  **uncr4ck4ble_k3yle$$** and the result of *function2*. In *function2* the content of file **ch2.key** is obtained and then its content and the string mentioned above are used to encrypt it with AES in *function3*.

![](/images/posts/CyberTruck19/img8.png "Challange 2 code")

With the following *Frida* script we are going to modify the implementation of functions two and three, in order to see the content of the file and the final result with the dynamic key.

![](/images/posts/CyberTruck19/img9.png "Frida script")

We see that the content of the file **d474_47_47_r357_mu57_pR073C73D700!** is used as a key to encrypt the seed **uncr4ck4ble_k3yle$$** and the final result is **5121...4f16**.

![](/images/posts/CyberTruck19/img10.png "Dynamic key")

### Challange 3

The last challenge raises the difficulty a little more and hides the code somewhere other than Java. If we remember the analysis of the `MainActivity`, we find a native function `init` that is most likely found in the `native-lib.so`  library. The `public native void init()` method serves as an interface between the application's Java code and the NDK. Through the Java Native Interface (JNI) we can execute native C or C++ functions that increase performance and help hide certain parts of the code. 

![](/images/posts/CyberTruck19/img13.png "Load native library and init")

Let's quickly see what we can find inside this library. We see some suspicious strings that could be related to the dynamic key and we also see the string **Java_org_nowsecure_cybertrick_MainActivity_init** related to the function that we mentioned before.

![](/images/posts/CyberTruck19/img11.png "Native library")

For this test we will use a tool that allows us to analyze the native code (in this case *Ghidra* but we could opt for *IDA*, *Radare2*, *Iaito*, *Binary Ninja*, etc.). For example, we can see the same string information in more detail and follow its references.

![](/images/posts/CyberTruck19/img12.png "Strings")

Following the description of the init function in Java, we arrive to the assembly code. On the right side we can see more easily how the function contains some initialization and then there is a loop.

![](/images/posts/CyberTruck19/img14.png "Init function")

To further facilitate the analysis of this function, we are going to decompile the function and obtain a C-like code that allows us to read it better. We see that once the challenge log is printed, certain variables are initialized and then used inside the loop in an XOR operation. It looks like the loop is being used to decrypt the information with the initialized information.

![](/images/posts/CyberTruck19/img15.png "Init function decompliled")

In order to hook the native function with *Frida*, this time we will first have to wait for the library used by the application. Just before it is loaded, we will list the exported methods of the module and when we find the function we are interested in we will inject in the code.

![](/images/posts/CyberTruck19/img16.png "Frida script for native library")

The easiest solution would be to get the key directly after the loop is finished. In the assembler code we can see that at offset **000106ea** it has just exited the loop and therefore we can find the key at the **ECX** address. With the *Interceptor* module, we will attach to the offset and read the string that is in memory in the ECX register.

![](/images/posts/CyberTruck19/img17.png "Interceptor")

Bingo! We can read the key but there is a certain part that appears malformed. Let's think of another solution to make sure what is the content of the dynamic key.

![](/images/posts/CyberTruck19/img18.png "Dynamic native key")

Another option is to use the *Interceptor* inside the loop and get the **EAX** and **ECX** registers to perform the XOR operation at each iteration of the key.

![](/images/posts/CyberTruck19/img19.png "New interceptor")

Perfect, now we have the content of the key **backd00r$Mus$tAlw4ysBeF0rb1dd3n$$[** . If we look at EAX we find the string that is used as seed and in ECX the encryption key.

![](/images/posts/CyberTruck19/img20.png "Dynamic native key")

### Bonus clip

As an alternative way to obtain the secret, we could extract the key inside the code (the variables that we have discussed in the static analysis of the decompilation). With *Python* we can reverse the process and obtain the dynamic key.

![](/images/posts/CyberTruck19/img21.png "Python decrypt")
